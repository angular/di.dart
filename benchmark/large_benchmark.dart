import 'package:benchmark_harness/benchmark_harness.dart';
import 'package:di/di.dart';
import 'package:di/src/reflector_static.dart';

/**
 * Generated by scripts/class_gen.dart
 * Run script from root directory, or run ./run-benchmarks.sh
 */
import 'generated_files/factories.dart' as f;

import 'dart:math';

/**
 * This benchmark creates tree where each injector has BRANCHING_FACTOR children
 * and binds a new module with 5 keys. It tests climbing up the injector tree to
 * find a provider, though in v2 caching means that this benchmark will always hit
 * the cache instead, and then becomes a benchmark to test memory usage of a large
 * number of injectors with a large number of keys.
 */
const int DEPTH = 5;
const int BRANCHING_FACTOR = 5;
const int BINDINGS_PER_INJECTOR = 5;
typedef Injector InjectorFactory(List<Module> modules);
class LargeBenchmark extends BenchmarkBase {
  InjectorFactory injectorFactory;
  Injector rootInjector;
  Injector leafInjector;
  Key leafKey;
  Random random = new Random(0);
  List<Injector> allLeaves = [];

  LargeBenchmark(name, this.injectorFactory) : super("Large" + name);

  /// creates width children for injector, and recursively creating children for the children
  /// up to depth levels. Returns number created.
  int createChildren(injector, depth, width) {
    if (depth <= 0) {
      allLeaves.add(injector);
      return 1;
    }
    int numInjectors = 1;
    for (var i = 0; i < width; i++) {
      var module = new Module();
      for (var j = 0; j < BINDINGS_PER_INJECTOR; j++) {
        // random since the key makes no difference, as long as it's not in the root
        leafKey = f.allKeys[random.nextInt(995)]; // 995: all keys except the 5 in root
        module.bindByKey(leafKey);
      }
      leafInjector = injector.createChild([module]);
      numInjectors += createChildren(leafInjector, depth-1, width);
    }
    return numInjectors;
  }

  setup() {
    var rootModule = new Module()
        ..bindByKey(f.key999)
        ..bindByKey(f.key998)
        ..bindByKey(f.key997)
        ..bindByKey(f.key996)
        ..bindByKey(f.key995);
    rootInjector = injectorFactory([rootModule]);

    var numInjectors = createChildren(rootInjector, DEPTH, BRANCHING_FACTOR);
    print("$numInjectors injectors created.");
  }
}

class GetFromRoot extends LargeBenchmark {
  GetFromRoot()
      : super('FromRoot', (m) => new ModuleInjector(m));

  run() {
    leafInjector.getByKey(f.key999);
    leafInjector.getByKey(f.key998);
    leafInjector.getByKey(f.key997);
    leafInjector.getByKey(f.key996);
    leafInjector.getByKey(f.key995);
  }
}

class GetFromLeaf extends LargeBenchmark {
  GetFromLeaf()
      : super('FromLeaf', (m) => new ModuleInjector(m));

  run() {
    leafInjector.getByKey(leafKey);
    leafInjector.getByKey(leafKey);
    leafInjector.getByKey(leafKey);
    leafInjector.getByKey(leafKey);
    leafInjector.getByKey(leafKey);
  }
}

main() {
  Module.DEFAULT_REFLECTOR = new GeneratedTypeFactories(f.typeFactories, f.parameterKeys);
  new GetFromRoot().report();
  new GetFromLeaf().report();
}
